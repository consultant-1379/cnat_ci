import pytest
import sys
from os.path import join, dirname, abspath
sys.path.append(dirname(dirname(abspath(__file__))))
from utility import test_class
from utility.test_class import BasicTest
from common.consts import (
    REPO_PATH,
    BATCH_FILE,
    LAB,
    CLUSTER,
    INSTANCE,
    KUBECTL,
    CNF1_CSAR_PATH,
    CNF2_CSAR_PATH,
    CNF1_CSAR_PACKAGE_NAME,
    CNF2_CSAR_PACKAGE_NAME
)


@pytest.fixture()
def args():
    batch_cnfs = test_class.get_batch_cnfs(BATCH_FILE)
    return {'single_cnf': "ccrc", 'batch_cnfs': batch_cnfs}


class TestWithCfggenClass(BasicTest):

    # @pytest.mark.skip(reason="no")
    def test_batch_onboard_csar_from_url(self):
        batch_csars = [CNF1_CSAR_PACKAGE_NAME, CNF2_CSAR_PACKAGE_NAME]
        # step1: update the env file
        env = {
            "export": {
                "enabled": True,
                "archive": True,
                "path": self.log_path
            }
        }
        self.update_env(env)
        # step2: run the batch onboarding with csar url and check the screen log is as expected
        batch_onboard = f'-e {LAB} -o {CNF1_CSAR_PATH}/{CNF1_CSAR_PACKAGE_NAME} {CNF2_CSAR_PATH}/{CNF2_CSAR_PACKAGE_NAME} -b2'
        self.run_cnat_cmd(batch_onboard)
        check_res = {
            batch_onboard: {
                "exist": [f'/tmp/{csar} is onboarded successfully' for csar in batch_csars]
            }
        }
        print("Batch onboarding command:", batch_onboard)
        print("Check results:", check_res)
        self.check_logs('cnat_screen', check_res)

    # @pytest.mark.skip(reason="no")
    def test_batch_install(self, args):
        batch_cnfs = args['batch_cnfs']
        # step1: cleanup evnfm by uninstalling all CNFs, if no resources exist, also fine
        cnf_name = [f'{INSTANCE}-{cnf}1' for cnf in batch_cnfs]
        batch_uninstall = f"-e {LAB} -bu {' '.join(cnf_name)} --cleanup -y -b 2"
        self.run_cnat_cmd(batch_uninstall)
        show_env = f'-e {LAB}'
        self.run_cnat_cmd(show_env)
        # step2: delete all resources in the target namespace, if no resources exist, also fine
        delete_all_resources = {
            f"{KUBECTL} delete all --all -n {cnf}": {} for cnf in batch_cnfs
        }
        self.check_logs(f'{LAB}-{INSTANCE}', delete_all_resources)
        # step3: remove the namespace, if the ns is not exist, also fine
        remove_ns = {
            f"{KUBECTL} delete ns {cnf}": {} for cnf in batch_cnfs
        }
        self.check_logs(f'{LAB}-{INSTANCE}', remove_ns)
        # step4: delete all files generated by cfggen
        for cnf in batch_cnfs:
            self.delete_exist_cfggen(join(REPO_PATH, f'config/{LAB}/{CLUSTER}/{cnf}'))
        # step5: run the batch install and check the screen log is as expect
        batch_install = f'-e {LAB} --bi {BATCH_FILE}'
        self.run_cnat_cmd(batch_install)
        check_res = {
            batch_install: {
                "exist": ['Loading CFGGEN info file'] +
                         [f'{INSTANCE}-{cnf}1 is installed successfully.' for cnf in batch_cnfs]
            }
        }
        self.check_logs('cnat_screen', check_res)
        # step6: check the CNF is instantiated
        self.run_cnat_cmd(show_env)
        check_point = {
            show_env: {
                "exist": [f'{INSTANCE}-{cnf}1.*INSTANTIATED.*COMPLETED' for cnf in batch_cnfs]
            }
        }
        self.check_logs('cnat_screen', check_point)

    # @pytest.mark.skip(reason="no")
    def test_batch_uninstall(self, args):
        batch_cnfs = args['batch_cnfs']
        # step1: check the CNF exist
        show_env = f'-e {LAB}'
        self.run_cnat_cmd(show_env)
        check_point = {
            show_env: {
                "exist": [f'{INSTANCE}-{cnf}1' for cnf in batch_cnfs]
            }
        }
        self.check_logs('cnat_screen', check_point)
        # step2: run batch uninstall and check the screen log is as expect
        cnf_name = [f'{INSTANCE}-{cnf}1' for cnf in batch_cnfs]
        batch_uninstall = f"-e {LAB} -bu {' '.join(cnf_name)} --cleanup -y -b 2"
        self.run_cnat_cmd(batch_uninstall)
        check_point = {
            batch_uninstall: {
                "exist": [f'{INSTANCE}-{cnf}1 is uninstalled successfully.' for cnf in batch_cnfs]
            }
        }
        self.check_logs('cnat_screen', check_point)
        # step3: check the CNF is terminated from evnfm info
        self.run_cnat_cmd(show_env)
        check_res = {
            show_env: {
                "absent": [f'{INSTANCE}-{cnf}1' for cnf in batch_cnfs]
            }
        }
        self.check_logs('cnat_screen', check_res)
        # step4: check the namespace is deleted
        ssh_cmd = {
            f"{KUBECTL} get ns": {
                "absent": [f'{cnf}' for cnf in batch_cnfs]
            }
        }
        self.check_logs(f'{LAB}-{INSTANCE}', ssh_cmd)

    # @pytest.mark.skip(reason="no")
    def test_single_install(self, args):
        single_cnf = args['single_cnf']
        # step1: update the env file
        env = {
            "export": {
                "enabled": True,
                "archive": False,
                "path": self.log_path
            }
        }
        self.update_env(env)
        # step2: check the CNF not instantiated from evnfm info
        show_env = f'-e {LAB}'
        self.run_cnat_cmd(show_env)
        check_point = {
            show_env: {
                "absent": [f'{INSTANCE}-{single_cnf}1.*INSTANTIATED.*COMPLETED'],
            }
        }
        self.check_logs('cnat_screen', check_point)
        # step3: check no pod in the target namespace
        check_pod = {
            f"{KUBECTL} get pod -n {single_cnf}": {
                "absent": ["NAME"]
            }
        }
        self.check_logs(f'{LAB}-{INSTANCE}', check_pod)
        # step4: remove the namespace, if the ns is not exist, also fine
        remove_ns = {
            f"{KUBECTL} delete ns {single_cnf}": {}
        }
        self.check_logs(f'{LAB}-{INSTANCE}', remove_ns)
        # step5: delete all files generated by cfggen
        self.delete_exist_cfggen(join(REPO_PATH, f'config/{LAB}/{CLUSTER}/{single_cnf}'))
        # step6: run the single install, and check the screen log is as expect
        install = f'-e {LAB} -i'
        self.run_cnat_cmd(install, join(REPO_PATH, f'config/{LAB}/{CLUSTER}/{single_cnf}'))
        check_res = {
            install: {
                "exist": ["Loading CFGGEN info file", f"'{INSTANCE}-{single_cnf}1' is installed"]
            }
        }
        self.check_logs('cnat_screen', check_res)
        # step7: check the CNF is instantiated
        self.run_cnat_cmd(show_env)
        check_point = {
            show_env: {
                "exist": [f'{INSTANCE}-{single_cnf}1.*INSTANTIATED.*COMPLETED']
            }
        }
        self.check_logs('cnat_screen', check_point)

    # @pytest.mark.skip(reason="no")
    def test_single_uninstall(self, args):
        cnf = args['single_cnf']
        # step1: check the CNF exist in evnfm
        show_env = f'-e {LAB}'
        self.run_cnat_cmd(show_env)
        check_point = {
            show_env: {
                "exist": [f'{INSTANCE}-{cnf}1']
            }
        }
        self.check_logs('cnat_screen', check_point)
        # step2: run single uninstall and check the screen log is as expect
        single_uninstall = f"-e {LAB} -t {INSTANCE}-{cnf}1 --cleanup -y"
        self.run_cnat_cmd(single_uninstall)
        check_delete = {
            single_uninstall: {
                "exist": [f"'{INSTANCE}-{cnf}1' is uninstalled"]
            }
        }
        self.check_logs('cnat_screen', check_delete)
        # step3: check the CNF is terminated from evnfm info
        self.run_cnat_cmd(show_env)
        check_res = {
            show_env: {
                "absent": [f'{INSTANCE}-{cnf}1']
            }
        }
        self.check_logs('cnat_screen', check_res)
        # step4: check the namespace is deleted
        ssh_cmd = {
            f"{KUBECTL} get ns": {
                "absent": [cnf]
            }
        }
        self.check_logs(f'{LAB}-{INSTANCE}', ssh_cmd)